--- 
 layout: default 
 title: "http2.0" 
--- 
## 主要优化点

### 二进制分帧

HTTP2 采用二进制传输将请求和数据切割为帧，http1.1基于文本格式，其中帧对数据进行顺序标识多路复用，同域名下能达到一个TCP连接传输所有的请求数据 请求都是基于流

流可以承载双向消息，每个流都有一个唯一的整数ID

![ae5418b7da1c6593fd6addad0310faa5_720w](.\ae5418b7da1c6593fd6addad0310faa5_720w.jpg)

![d9f07162d5391641b7a2645a61b24fc0_720w](.\d9f07162d5391641b7a2645a61b24fc0_720w.png)

### 多路复用

keep-alive

![企业微信截图_1657851423397](.\企业微信截图_1657851423397.png)

同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗
单个连接上可以并行交错的请求和响应，之间互不干扰

![b1e608ddb7493608efea3e76912aabe1_720w](.\b1e608ddb7493608efea3e76912aabe1_720w.jpg)

### 头部压缩

http1请求头的大小变得越来越大，有时甚至会大于TCP窗口的初始大小导致需要等待带着ACK的响应回来以后才能继续被发送。

http2采用HPACK算法对头部进行压缩，通讯双方各自缓存一份头部字段表避免发送重复header

如果已存在表中则只发送索引，否则需要发送内容并加入头部字段表



### 请求优先级

每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧

### 服务端推送

服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端



## http2.0的问题及http3.0

问题：

1、如果有丢包请求会等待重传，阻塞后面的数据，有可能不如http1.1的多个TCP连接以及 TCP+TLS 建立连接的延时
2、TCP 的队头阻塞并没有彻底解决 TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认
3、多路复用导致服务器压力上升，多路复用没有限制同时请求数。瞬时请求过多。
4、多路复用容易 Timeout  大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。

http3.0
基于UDP的QUIC协议

乱序重排、报文重传等

## 例子

https://www.tencent.com/

> waterfall
>
> Queueing 排队，需要排队的情况： 1、有更高优先级的请求； 2、TCP链接达到上限（同一个域名）；3、浏览器正在磁盘缓存中短暂分配空间
>
> Stalled 阻塞
>
> DNS Lookup 域名解析的时间
>
> Initial connection TCP握手/重试，协商SSL
>
> SSL SSL/TLS握手建立连接
>
> Request sent 请求发送时间，即请求的header、body全部发送出去的时间
>
> Waiting for server response 等待服务器响应的时间，即请求发出后到接收到第一个字节的时间，包括请求内容传输到服务器+服务器处理+服务器返回内容传输到客户端
>
> Content Download 下载资源的时间，即从接收到第一个字节到所有内容接收完毕的时间





